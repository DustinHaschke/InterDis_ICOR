# -*- coding: utf-8 -*-
"""ICOR- InterDis Dustin Haschke.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qTX_P8dL7S_4_IQyrZ_NTF3Kul6JAk5t

####Optionaler Code für Bilddownloads
"""

#pip install kaleido
#!pip uninstall ploty !pip install plotly==5.3.1 import plotly import kaleido


!pip install kaleido
import kaleido #required
kaleido.__version__ #0.2.1

import plotly
plotly.__version__ #5.5.0

#now this works:
import plotly.graph_objects as go

import kaleido

"""### Bilder generieren"""

# ICOR          #A = a+d / a+b+c+d  element [0,1]   #    P = a+e/a+b+c+d


import numpy as np
import plotly.graph_objects as plt

import math

def werte_generator():
    liste = []
    for a in np.linspace(0, 1, praezision + 1):
        for d in np.linspace(0, 1 - a, praezision + 1):
            if not(a + d == 1):
              e = (1 - a - d) / 2
              c = c_anteil * 2 * e
              b = (1-c_anteil) * 2 * e
              v_agreement = a + d / (a+2*e+d)
              v_prevalence = a + e / (a+2*e+d)
              v_icor = (a * d) / (e ** 2)
              v_pi = (a*d-e**2)/((a+e)*(e+d))
              v_kappa = (a*d-b*c) / ((0.5*(a+b)*(b+d) + 0.5*(a+c)*(c+d)))

              v_icor_mult_1_min_kap = v_icor*(1-v_kappa)
              v_icor_min = (1+v_pi)**2 / (1-v_pi)**2
              if not(v_kappa==0):
                  v_icor_div_kappa = v_icor / v_kappa
              v_pi_minus_kappa = v_pi - v_kappa

              v_agreement_dividedby_prevalence = v_agreement / v_prevalence


              liste.append((v_agreement, v_prevalence, v_icor, v_pi, v_kappa, v_icor_min, v_icor_div_kappa, v_pi_minus_kappa, v_icor_mult_1_min_kap, v_agreement_dividedby_prevalence))
    return liste

def plotter(x_werte, y_werte, z_werte, achsenname_x, achsenname_y, achsenname_z, titel, skala_min, skala_max, kappa_vorhanden=0, x_min=0, x_max=1, y_min =0, y_max=1):
    global c_anteil
    if kappa_vorhanden:
        if c_anteil == 1/2:
            ein_name = titel + " (mit c/(b+c) =" + str(c_anteil) +",also Kappa=Pi)"
        else:
            ein_name = titel + " (mit c/(b+c) =" + str(c_anteil) +")"
    else:
        ein_name = titel
    new_graphic = plt.Figure(data=[
        plt.Scatter3d(x=x_werte, y=y_werte, z=z_werte, mode='markers',
                    marker=dict(size=5, color=z_werte, colorscale='Rainbow', colorbar=dict(title=achsenname_z), cmax=skala_max, cmin=skala_min))
    ])

    new_graphic.update_layout(
        scene=dict(
            xaxis=dict(title=achsenname_x, range=[x_min, x_max], title_font=dict(size=achsen_schriftgroesse), tickfont=dict(size=achsenwerte_groesse)),
            yaxis=dict(title=achsenname_y, range=[y_min, y_max], title_font=dict(size=achsen_schriftgroesse), tickfont=dict(size=achsenwerte_groesse)),
            zaxis=dict(title=achsenname_z, range=[skala_min, skala_max], title_font=dict(size=achsen_schriftgroesse), tickfont=dict(size=achsenwerte_groesse))
        ),
        title=ein_name
    )

    return new_graphic


#variable Werte für die Präzision und den c_Anteil
praezision = 250     #variable Wert für die Präzision
c_anteil = 1/6      #variable Wert für den c_Anteil (beeinflusst kappa; kappa = pi für Wert von 0.5)
achsen_schriftgroesse = 23 # variabler Wert für die Achsenschriftgröße
achsenwerte_groesse = 14

agreement, prevalence, icor, pi, kappa, icor_min, icor_div_kappa, pi_minus_kappa, icor_mult_1_min_kap, agreement_dividedby_prevalence = zip(*werte_generator())

# füge interaktiv weitere Grafiken über Variablen im Format "fig_<zahl>" hinzu
# benutze in der plotter()-Funktion die Argumente für plotter(x_werte, y_werte, z_werte, achsenname_x, achsenname_y, achsenname_z, titel, skala_min, skala_max, kappa_vorhanden=0)
# mögliche Werte sind: [agreement, prevalence, icor, pi, kappa, icor_min, icor_div_kappa, pi_minus_kappa, icor_mult_1_min_kap, agreement_dividedby_prevalence]

#ICOR, Pi und Kappa in Abhängigkeit von A und P
fig_1 = plotter(agreement, prevalence, icor, "Agreement", "Prävalenz", "ICOR", "ICOR in Abh. von A, P",0,100)
fig_2 = plotter(agreement, prevalence, pi, "Agreement", "Prävalenz", "PI","Scotts Pi in Abh. von A,P",-1,1)
fig_3 = plotter(agreement, prevalence, kappa, "Agreement", "Prävalenz", "Kappa","Cohens Kappa in Abh. von A,P",-1,1,1)

# Hier zeigt sich, dass für P=0.5 Pi und Kappa gleich sind:
fig_4 = plotter(agreement, prevalence, pi_minus_kappa, "Agreement", "Prävalenz", "Pi-Kappa","Pi minus Kappa in Abh. von Übereinstimmung und Prävalenz",-1,1,1)

# untere Schranke von ICOR
fig_5 = plotter(agreement, prevalence, icor_min, "Agreement", "Prävalenz", "ICOR - min(ICOR)","ICOR-min(ICOR) in Abh. von A,P",0,1)

# Verhältnis von ICOR zu Kappa mit A/P
fig_6 = plotter(agreement_dividedby_prevalence, kappa, icor, "A/P", "Kappa", "ICOR","Kappa, ICOR zu A/P",0,100,1,0,3,-1,1)

#weitere unbenutzte Abbildungen
#fig_7 = plotter(agreement, prevalence, icor_mult_1_min_kap, "Agreement", "Prävalenz", "ICOR*(1-Kappa)","ICOR*(1-Kappa) in Abh. von Übereinstimmung und Prävalenz",0,1,1)
#fig_8 = plotter(agreement, prevalence, icor_mult_1_min_kap, "Agreement", "Prävalenz", "ICOR*(1-Kappa)","ICOR*(1-Kappa) in Abh. von Übereinstimmung und Prävalenz",0,10,1)
#fig_9 = plotter(agreement, prevalence, icor_mult_1_min_kap, "Agreement", "Prävalenz", "ICOR*(1-Kappa)","ICOR*(1-Kappa) in Abh. von Übereinstimmung und Prävalenz",0,100,1)
#fig_5 = plotter(agreement, prevalence, icor_div_kappa, "Agreement", "Prävalenz", "ICOR/Kappa","ICOR/Kappa in Abh. von Übereinstimmung und Prävalenz",0,100,1)

# Anzeigen aller Plots
neue_liste=[]
neue_liste.extend(value for name, value in globals().items() if name.startswith('fig'))

for element in neue_liste:
    element.show()

#optionales abspeichern, erfordert kaleido:
#i=0
#for element in neue_liste:
#    element.write_image("scatter_plot", str(i), ".png")
#    i += 1

"""# Tabellen und ICOR zu KAPPA"""

from tabulate import tabulate
import numpy as np
import plotly.graph_objects as plt
import math

def werte_generator(praezision):
    liste = []
    c_anteile_liste= [1/100, 1/8, 1/6, 1/4,  1/2 ]
    for c_anteil in c_anteile_liste:
      for a in np.linspace(0, 1, praezision + 1):
          for d in np.linspace(0, 1 - a, praezision + 1):
              if not(a + d == 1):
                e = (1 - a - d) / 2
                c = c_anteil * 2 * e
                b = (1-c_anteil) * 2 * e
                v_agreement = a + d / (a+2*e+d)
                v_prevalence = a + e / (a+2*e+d)
                v_icor = (a * d) / (e ** 2)
                v_pi = (a*d-e**2)/((a+e)*(e+d))
                v_kappa = (a*d-b*c) / ((0.5*(a+b)*(b+d) + 0.5*(a+c)*(c+d)))


                liste.append((c_anteil,a,b,c,d,e,v_agreement, v_prevalence, v_icor, v_pi, v_kappa))
    return liste



def plotter(x_werte, y_werte, z_werte, achsenname_x, achsenname_y, achsenname_z, titel, skala_min, skala_max, kappa_vorhanden=0):
    global c_anteil
    if kappa_vorhanden:
        if c_anteil == 1/2:
            ein_name = titel + " (mit c/(b+c) =" + str(c_anteil) +",also Kappa=Pi)"
        else:
            ein_name = titel + " (mit c/(b+c) =" + str(c_anteil) +")"
    else:
        ein_name = titel
    new_graphic = plt.Figure(data=[
        plt.Scatter3d(x=x_werte, y=y_werte, z=z_werte, mode='markers',
                    marker=dict(size=5, color=z_werte, colorscale='Rainbow', colorbar=dict(title=achsenname_z), cmax=skala_max, cmin=skala_min))
    ])

    new_graphic.update_layout(scene=dict(xaxis_title=achsenname_x, xaxis=dict(range=[0, 100]), yaxis_title=achsenname_y, zaxis_title=achsenname_z, zaxis=dict(range=[-1, 1]), xaxis_title_font=dict(size=achsen_schriftgroesse), yaxis_title_font=dict(size=achsen_schriftgroesse), zaxis_title_font=dict(size=achsen_schriftgroesse)))

    return new_graphic


#variable Werte für die Präzision und den c_Anteil
praezision1 = 10     #variabler Wert für die Präzision der Tabelle
achsen_schriftgroesse = 20 # variabler Wert für die Achsenschriftgröße

c_anteil,a,b,c,d,e,agreement, prevalence, icor, pi, kappa = zip(*werte_generator(praezision1))

data = zip(c_anteil, icor, pi, kappa)
data = sorted(data, key=lambda x: (x[1], x[0]))
table1 = tabulate(data, headers=["denominator_c","ω", " κ", "π"], tablefmt="grid")

data2 = zip(c_anteil, icor, pi, kappa,agreement, prevalence)
data2 = sorted(data2, key=lambda x: (x[4], x[5], x[1]))
table2 = tabulate(data2, headers=["denominator_c","ω", " κ", "π","Agreement","prevalence"], tablefmt="grid")

data3 = zip(c_anteil, icor, pi, kappa,agreement, prevalence, a,b,c,d,e)
data3 = sorted(data3, key=lambda x: (x[4], x[5], x[1]))
table3 = tabulate(data3, headers=["denominator_c","ω", " κ", "π","Agreement","prevalence","a","b","c","d","e",], tablefmt="grid")

print(table1)
print(table2)
print(table3)

#neuer Abschnitt, welche einen Plot für Kappa und ICOR generiert:
praezision2 = 120    #variabler Wert für die Präzision der Grafik

c_anteil,a,b,c,d,e,agreement, prevalence, icor, pi, kappa = zip(*werte_generator(praezision2))


neue_fig_1 = plotter(icor, c_anteil, kappa, "icor", "denominator_c", "kappa", "Kappa in Abh. von ICOR und ausgewählten Denominatoren von c",-1,1)
neue_fig_2 = plotter(kappa, c_anteil, icor, "kappa", "denominator_c", "ICOR", "ICOR in Abh. von Kappa und ausgewählten Denominatoren von c",-1,1)

# Anzeigen aller Plots
neue_liste=[]
neue_liste.extend(value for name, value in globals().items() if name.startswith('neue_fig'))

for element in neue_liste:
    element.show()